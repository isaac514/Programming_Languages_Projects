
/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/
%union 
{
	char * str; 
	int value;
	struct KeyValuePair* IDnode;
	struct expr* expression;
}

%token <str>TOKEN_ID
%token TOKEN_INTEGER
%token TOKEN_ENDPROG
%token <value>TOKEN_INT
%token TOKEN_SEMI
%token TOKEN_PLUS
%token TOKEN_MINUS
%token TOKEN_MUL
%token TOKEN_DIV
%token TOKEN_LPAREN
%token TOKEN_RPAREN
%token TOKEN_SIN
%token TOKEN_ASSIGN
%token TOKEN_COS

%type <expression> program;
%type <expression> expr
%type <expression> term;
%type <expression> factor;
%type <IDnode> id;
%type <expression> statement;
%type <expression> statementList; 



%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "expr.h"

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/


#define YYERROR_VERBOSE 1

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct SymbolTable symtab;
struct KeyValuePair* pair; 
struct expr *expressionVar = 0;
struct expr* NodeArray[16];
int counter = 0;

%}

%%

/* Here is the grammar: program is the start symbol. */

program : statementList 	
	;

statementList	: statement TOKEN_SEMI '\n'
	| statementList statement TOKEN_ENDPROG
	{
		//Need to return the array of expressions 
		//and add the final expression to the array
		NodeArray[counter] = $2;
		return 0;
	}
	;

statement	: id TOKEN_ASSIGN expr 
	{
		/*update the value*/
			$1->value = $3;
			expressionVar = expr_create(EXPR_ASSIGN, $1->key , $3);
			NodeArray[counter] = expressionVar;
			counter++;
			$$ = expressionVar;
	}
	| expr
	{
		$$ = $1;
	}
	;

expr	: expr TOKEN_PLUS term
		{ $$ = expr_create(EXPR_ADD,$1,$3); }
	| expr TOKEN_MINUS term
		{ $$ = expr_create(EXPR_SUBTRACT,$1,$3); }
	| id TOKEN_PLUS term
		{ $$ = expr_create(EXPR_ADD,$1->value,$3); }
	| id TOKEN_MINUS term
		{ $$ = expr_create(EXPR_SUBTRACT,$1->value,$3); }
	| term
		{  $$ = $1; }
	;

id 		: TOKEN_ID
	{
		pair = getAddr_symTab(&symtab , $1);
		$$ = pair;
	}

term	: term TOKEN_MUL factor
		{ $$ = expr_create(EXPR_MULTIPLY,$1,$3); }
	| term TOKEN_DIV factor
		{ $$ = expr_create(EXPR_DIVIDE,$1,$3); }
	| id TOKEN_MUL factor
		{ $$ = expr_create(EXPR_MULTIPLY,$1->value,$3); }
	| id TOKEN_DIV factor
		{ $$ = expr_create(EXPR_DIVIDE,$1->value,$3); }
	| factor
		{   $$ = $1; }
	| id
		{$$ = expr_create_value($1->value); } 
		
	;

factor	: TOKEN_LPAREN expr TOKEN_RPAREN
		{ $$ = $2; }
	| TOKEN_MINUS factor
		{ $$ = expr_create(EXPR_SUBTRACT,expr_create_value(0),$2); }
	| TOKEN_SIN TOKEN_LPAREN expr TOKEN_RPAREN
	   { $$ = expr_create(EXPR_SIN,0,$3); }
	| TOKEN_COS TOKEN_LPAREN expr TOKEN_RPAREN
	   { $$ = expr_create(EXPR_COS,0,$3); }
	| TOKEN_INT
		{ $$ = expr_create_value(atoi(yytext)); }
	| id
		{$$ = expr_create_value($1->value); }
	;

%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
	return 0;
}
